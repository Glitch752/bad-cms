{"version":3,"sources":["../src/createSpreadMapper.js"],"names":["createSpreadMapper","path","stats","result","attributeNames","optionsDefaults","opts","attributes","Object","entries","filter","pair","attributeKeys","map","spreadAttributes","node","openingElement","attribute","forEach","spread","attributeKey","destinationName","argument"],"mappings":";;;;;;;AAEA;;AAWA;;;;AAEA,MAAMA,kBAAkB,GAAG,CAACC,IAAD,EAAUC,KAAV,KAGtB;AACH,QAAMC,MAAM,GAAG,EAAf;AAEA,MAAI;AAAEC,IAAAA;AAAF,MAAqBC,wBAAzB;;AAEA,MAAIH,KAAK,CAACI,IAAN,IAAcJ,KAAK,CAACI,IAAN,CAAWF,cAA7B,EAA6C;AAC3CA,IAAAA,cAAc,GAAG,EAAE,GAAGA,cAAL;AAAqB,SAAGF,KAAK,CAACI,IAAN,CAAWF;AAAnC,KAAjB;AACD;;AAED,QAAMG,UAAU,GAAGC,MAAM,CACtBC,OADgB,CACRL,cADQ,EAEhBM,MAFgB,CAERC,IAAD,IAAUA,IAAI,CAAC,CAAD,CAFL,CAAnB;AAIA,QAAMC,aAAa,GAAGL,UAAU,CAACM,GAAX,CAAgBF,IAAD,IAAUA,IAAI,CAAC,CAAD,CAA7B,CAAtB;AAEA,QAAMG,gBAAgB,GAAGb,IAAI,CAACc,IAAL,CAAUC,cAAV,CAAyBT,UAAzB,CACtBG,MADsB,CACdO,SAAD,IAAe,iCAAqBA,SAArB,CADA,CAAzB;AAGAH,EAAAA,gBAAgB,CAACI,OAAjB,CAA0BC,MAAD,IAAY;AACnCP,IAAAA,aAAa,CAACM,OAAd,CAAuBE,YAAD,IAAkB;AACtC,YAAMC,eAAe,GAAGjB,cAAc,CAACgB,YAAD,CAAtC;;AAEA,UAAIjB,MAAM,CAACkB,eAAD,CAAV,EAA6B;AAC3BlB,QAAAA,MAAM,CAACkB,eAAD,CAAN,GAA0B,6BACxB,GADwB,EAExBlB,MAAM,CAACkB,eAAD,CAFkB,EAGxB,kCACE,sBAAUF,MAAM,CAACG,QAAjB,CADF,EAEE,6BACE,GADF,EAEE,0BAAc,GAAd,CAFF,EAGE,8BACE,IADF,EAEE,6BACE,sBAAUH,MAAM,CAACG,QAAjB,CADF,EAEE,uBAAWD,eAAX,CAFF,CAFF,EAME,0BAAc,EAAd,CANF,CAHF,CAFF,EAcE,0BAAc,EAAd,CAdF,CAHwB,CAA1B;AAoBD,OArBD,MAqBO;AACLlB,QAAAA,MAAM,CAACkB,eAAD,CAAN,GAA0B,kCACxB,sBAAUF,MAAM,CAACG,QAAjB,CADwB,EAExB,8BACE,IADF,EAEE,6BACE,sBAAUH,MAAM,CAACG,QAAjB,CADF,EAEE,uBAAWD,eAAX,CAFF,CAFF,EAME,0BAAc,EAAd,CANF,CAFwB,EAUxB,0BAAc,EAAd,CAVwB,CAA1B;AAYD;AACF,KAtCD;AAuCD,GAxCD;AA0CA,SAAOlB,MAAP;AACD,CAhED;;eAkEeH,kB","sourcesContent":["// @flow\n\nimport {\n  cloneNode,\n  Expression,\n  memberExpression,\n  binaryExpression,\n  conditionalExpression,\n  stringLiteral,\n  logicalExpression,\n  identifier,\n  isJSXSpreadAttribute,\n} from '@babel/types';\nimport optionsDefaults from './schemas/optionsDefaults';\n\nconst createSpreadMapper = (path: *, stats: *): {\n  [destinationName: string]: typeof Expression,\n  ...\n} => {\n  const result = {};\n\n  let { attributeNames } = optionsDefaults;\n\n  if (stats.opts && stats.opts.attributeNames) {\n    attributeNames = { ...attributeNames, ...stats.opts.attributeNames };\n  }\n\n  const attributes = Object\n    .entries(attributeNames)\n    .filter((pair) => pair[1]);\n\n  const attributeKeys = attributes.map((pair) => pair[0]);\n\n  const spreadAttributes = path.node.openingElement.attributes\n    .filter((attribute) => isJSXSpreadAttribute(attribute));\n\n  spreadAttributes.forEach((spread) => {\n    attributeKeys.forEach((attributeKey) => {\n      const destinationName = attributeNames[attributeKey];\n\n      if (result[destinationName]) {\n        result[destinationName] = binaryExpression(\n          '+',\n          result[destinationName],\n          conditionalExpression(\n            cloneNode(spread.argument),\n            binaryExpression(\n              '+',\n              stringLiteral(' '),\n              logicalExpression(\n                '||',\n                memberExpression(\n                  cloneNode(spread.argument),\n                  identifier(destinationName),\n                ),\n                stringLiteral(''),\n              ),\n            ),\n            stringLiteral(''),\n          ),\n        );\n      } else {\n        result[destinationName] = conditionalExpression(\n          cloneNode(spread.argument),\n          logicalExpression(\n            '||',\n            memberExpression(\n              cloneNode(spread.argument),\n              identifier(destinationName),\n            ),\n            stringLiteral(''),\n          ),\n          stringLiteral(''),\n        );\n      }\n    });\n  });\n\n  return result;\n};\n\nexport default createSpreadMapper;\n"],"file":"createSpreadMapper.js"}