"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = require("path");

var _pluginSyntaxJsx = _interopRequireDefault(require("@babel/plugin-syntax-jsx"));

var _types = _interopRequireDefault(require("@babel/types"));

var _ajv = _interopRequireDefault(require("ajv"));

var _ajvKeywords = _interopRequireDefault(require("ajv-keywords"));

var _attributeNameExists = _interopRequireDefault(require("./attributeNameExists"));

var _createObjectExpression = _interopRequireDefault(require("./createObjectExpression"));

var _createSpreadMapper = _interopRequireDefault(require("./createSpreadMapper"));

var _handleSpreadClassName = _interopRequireDefault(require("./handleSpreadClassName"));

var _replaceJsxExpressionContainer = _interopRequireDefault(require("./replaceJsxExpressionContainer"));

var _requireCssModule = _interopRequireDefault(require("./requireCssModule"));

var _resolveStringLiteral = _interopRequireDefault(require("./resolveStringLiteral"));

var _optionsDefaults = _interopRequireDefault(require("./schemas/optionsDefaults"));

var _optionsSchema = _interopRequireDefault(require("./schemas/optionsSchema.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ajv = new _ajv.default({
  $data: true
});
(0, _ajvKeywords.default)(ajv);
const validate = ajv.compile(_optionsSchema.default);

const getTargetResourcePath = (path, stats) => {
  const targetFileDirectoryPath = (0, _path.dirname)(stats.file.opts.filename);

  if (path.node.source.value.startsWith('.')) {
    return (0, _path.resolve)(targetFileDirectoryPath, path.node.source.value);
  }

  return require.resolve(path.node.source.value);
};

const isFilenameExcluded = (filename, exclude) => filename.match(new RegExp(exclude, 'u'));

const notForPlugin = (path, stats) => {
  const extension = path.node.source.value.lastIndexOf('.') > -1 ? path.node.source.value.slice(path.node.source.value.lastIndexOf('.')) : null;

  if (extension !== '.css') {
    const {
      filetypes
    } = stats.opts;
    if (!filetypes || !filetypes[extension]) return true;
  }

  const filename = getTargetResourcePath(path, stats);

  if (stats.opts.exclude && isFilenameExcluded(filename, stats.opts.exclude)) {
    return true;
  }

  return false;
};

var _default = ({
  types
}) => {
  const filenameMap = {};
  let skip = false;

  const setupFileForRuntimeResolution = (path, filename) => {
    const programPath = path.findParent(parentPath => parentPath.isProgram());
    filenameMap[filename].importedHelperIndentifier = programPath.scope.generateUidIdentifier('getClassName');
    filenameMap[filename].styleModuleImportMapIdentifier = programPath.scope.generateUidIdentifier('styleModuleImportMap');
    programPath.unshiftContainer('body', types.importDeclaration([types.importDefaultSpecifier(filenameMap[filename].importedHelperIndentifier)], types.stringLiteral('@dr.pogodin/babel-plugin-react-css-modules/dist/browser/getClassName')));
    const firstNonImportDeclarationNode = programPath.get('body').find(node => !types.isImportDeclaration(node));
    firstNonImportDeclarationNode.insertBefore(types.variableDeclaration('const', [types.variableDeclarator(types.cloneNode(filenameMap[filename].styleModuleImportMapIdentifier), (0, _createObjectExpression.default)(types, filenameMap[filename].styleModuleImportMap))]));
  };

  const addWebpackHotModuleAccept = path => {
    const test = types.memberExpression(types.identifier('module'), types.identifier('hot'));
    const consequent = types.blockStatement([types.expressionStatement(types.callExpression(types.memberExpression(types.memberExpression(types.identifier('module'), types.identifier('hot')), types.identifier('accept')), [types.stringLiteral(path.node.source.value), types.functionExpression(null, [], types.blockStatement([types.expressionStatement(types.callExpression(types.identifier('require'), [types.stringLiteral(path.node.source.value)]))]))]))]);
    const programPath = path.findParent(parentPath => parentPath.isProgram());
    const firstNonImportDeclarationNode = programPath.get('body').find(node => !types.isImportDeclaration(node));
    const hotAcceptStatement = types.ifStatement(test, consequent);

    if (firstNonImportDeclarationNode) {
      firstNonImportDeclarationNode.insertBefore(hotAcceptStatement);
    } else {
      programPath.pushContainer('body', hotAcceptStatement);
    }
  };

  return {
    inherits: _pluginSyntaxJsx.default,
    visitor: {
      ImportDeclaration(path, stats) {
        if (skip || notForPlugin(path, stats)) {
          return;
        }

        const {
          filename
        } = stats.file.opts;
        const targetResourcePath = getTargetResourcePath(path, stats);
        let styleImportName;

        if (path.node.specifiers.length === 0) {
          // use imported file path as import name
          styleImportName = path.node.source.value;
        } else if (path.node.specifiers.length === 1) {
          styleImportName = path.node.specifiers[0].local.name;
        } else {
          // eslint-disable-next-line no-console
          console.warn('Please report your use case. https://github.com/birdofpreyru/babel-plugin-react-css-modules/issues/new?title=Unexpected+use+case.');
          throw new Error('Unexpected use case.');
        }

        filenameMap[filename].styleModuleImportMap[styleImportName] = (0, _requireCssModule.default)(targetResourcePath, {
          context: stats.opts.context,
          filetypes: stats.opts.filetypes || {},
          generateScopedName: stats.opts.generateScopedName
        });

        if (stats.opts.webpackHotModuleReloading) {
          addWebpackHotModuleAccept(path);
        }

        if (stats.opts.removeImport) {
          path.remove();
        }
      },

      JSXElement(path, stats) {
        if (skip) {
          return;
        }

        const {
          filename
        } = stats.file.opts;

        if (stats.opts.exclude && isFilenameExcluded(filename, stats.opts.exclude)) {
          return;
        }

        let {
          attributeNames
        } = _optionsDefaults.default;

        if (stats.opts && stats.opts.attributeNames) {
          attributeNames = { ...attributeNames,
            ...stats.opts.attributeNames
          };
        }

        const attributes = path.node.openingElement.attributes.filter(attribute => typeof attribute.name !== 'undefined' && typeof attributeNames[attribute.name.name] === 'string');

        if (attributes.length === 0) {
          return;
        }

        const {
          handleMissingStyleName = _optionsDefaults.default.handleMissingStyleName,
          autoResolveMultipleImports = _optionsDefaults.default.autoResolveMultipleImports
        } = stats.opts || {};
        const spreadMap = (0, _createSpreadMapper.default)(path, stats);
        attributes.forEach(attribute => {
          const destinationName = attributeNames[attribute.name.name];
          const options = {
            autoResolveMultipleImports,
            handleMissingStyleName
          };

          if (types.isStringLiteral(attribute.value)) {
            (0, _resolveStringLiteral.default)(path, filenameMap[filename].styleModuleImportMap, attribute, destinationName, options);
          } else if (types.isJSXExpressionContainer(attribute.value)) {
            if (!filenameMap[filename].importedHelperIndentifier) {
              setupFileForRuntimeResolution(path, filename);
            }

            (0, _replaceJsxExpressionContainer.default)(types, path, attribute, destinationName, filenameMap[filename].importedHelperIndentifier, types.cloneNode(filenameMap[filename].styleModuleImportMapIdentifier), options);
          }

          if (spreadMap[destinationName]) {
            (0, _handleSpreadClassName.default)(path, destinationName, spreadMap[destinationName]);
          }
        });
      },

      Program(path, stats) {
        if (!validate(stats.opts)) {
          // eslint-disable-next-line no-console
          console.error(validate.errors);
          throw new Error('Invalid configuration');
        }

        const {
          filename
        } = stats.file.opts;
        filenameMap[filename] = {
          styleModuleImportMap: {}
        };

        if (stats.opts.skip && !(0, _attributeNameExists.default)(path, stats)) {
          skip = true;
        }
      }

    }
  };
};

exports.default = _default;
//# sourceMappingURL=index.js.map