{"version":3,"sources":["../src/replaceJsxExpressionContainer.js"],"names":["types","path","sourceAttribute","destinationName","importedHelperIndentifier","styleModuleImportMapIdentifier","options","expressionContainerValue","value","destinationAttribute","node","openingElement","attributes","find","attribute","name","splice","indexOf","args","expression","handleMissingStyleName","optionsDefaults","autoResolveMultipleImports","push","styleNameExpression","callExpression","clone","stringLiteral","Error"],"mappings":";;;;;;;AAEA;;AAUA;;AACA;;AACA;;;;;;;;eAKe,CACbA,KADa,EAEbC,IAFa,EAGbC,eAHa,EAIbC,eAJa,EAKbC,yBALa,EAMbC,8BANa,EAObC,OAPa,KAQJ;AACT,QAAMC,wBAAwB,GAAGL,eAAe,CAACM,KAAjD;AACA,QAAMC,oBAAoB,GAAGR,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAC1BC,IAD0B,CACpBC,SAAD,IAAe,OAAOA,SAAS,CAACC,IAAjB,KAA0B,WAA1B,IAAyCD,SAAS,CAACC,IAAV,CAAeA,IAAf,KAAwBZ,eAD3D,CAA7B;;AAGA,MAAIM,oBAAJ,EAA0B;AACxBR,IAAAA,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCI,MAApC,CACEf,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCK,OAApC,CAA4CR,oBAA5C,CADF,EAEE,CAFF;AAID;;AAEDR,EAAAA,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCI,MAApC,CACEf,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCK,OAApC,CAA4Cf,eAA5C,CADF,EAEE,CAFF;AAKA,QAAMgB,IAAI,GAAG,CACXX,wBAAwB,CAACY,UADd,EAEXd,8BAFW,CAAb,CAjBS,CAsBT;AACA;;AACA,MAAIC,OAAO,CAACc,sBAAR,KAAmCC,yBAAgBD,sBAAnD,IACCd,OAAO,CAACgB,0BAAR,KAAuCD,yBAAgBC,0BAD5D,EACwF;AACtFJ,IAAAA,IAAI,CAACK,IAAL,CAAU,qCAAuBvB,KAAvB,EAA8BM,OAA9B,CAAV;AACD;;AAED,QAAMkB,mBAAmB,GAAGxB,KAAK,CAACyB,cAAN,CAC1BzB,KAAK,CAAC0B,KAAN,CAAYtB,yBAAZ,CAD0B,EAE1Bc,IAF0B,CAA5B;;AAKA,MAAIT,oBAAJ,EAA0B;AACxB,QAAI,4BAAgBA,oBAAoB,CAACD,KAArC,CAAJ,EAAiD;AAC/CP,MAAAA,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCW,IAApC,CAAyC,yBACvC,0BAAcpB,eAAd,CADuC,EAEvC,mCACE,6BACE,GADF,EAEEH,KAAK,CAAC2B,aAAN,CAAqB,GAAElB,oBAAoB,CAACD,KAArB,CAA2BA,KAAM,GAAxD,CAFF,EAGEgB,mBAHF,CADF,CAFuC,CAAzC;AAUD,KAXD,MAWO,IAAI,qCAAyBf,oBAAoB,CAACD,KAA9C,CAAJ,EAA0D;AAC/DP,MAAAA,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCW,IAApC,CAAyC,yBACvC,0BAAcpB,eAAd,CADuC,EAEvC,mCACE,oCACEM,oBAAoB,CAACD,KAArB,CAA2BW,UAD7B,EAEEK,mBAFF,CADF,CAFuC,CAAzC;AASD,KAVM,MAUA;AACL,YAAM,IAAII,KAAJ,CAAW,+BAA8BnB,oBAAoB,CAACD,KAAM,EAApE,CAAN;AACD;AACF,GAzBD,MAyBO;AACLP,IAAAA,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCW,IAApC,CAAyC,yBACvC,0BAAcpB,eAAd,CADuC,EAEvC,mCACEqB,mBADF,CAFuC,CAAzC;AAMD;AACF,C","sourcesContent":["// @flow\n\nimport BabelTypes, {\n  binaryExpression,\n  Identifier,\n  isJSXExpressionContainer,\n  isStringLiteral,\n  jSXAttribute,\n  JSXAttribute,\n  jSXExpressionContainer,\n  jSXIdentifier,\n} from '@babel/types';\nimport conditionalClassMerge from './conditionalClassMerge';\nimport createObjectExpression from './createObjectExpression';\nimport optionsDefaults from './schemas/optionsDefaults';\nimport type {\n  GetClassNameOptionsType,\n} from './types';\n\nexport default (\n  types: typeof BabelTypes,\n  path: Object,\n  sourceAttribute: typeof JSXAttribute,\n  destinationName: string,\n  importedHelperIndentifier: typeof Identifier,\n  styleModuleImportMapIdentifier: typeof Identifier,\n  options: GetClassNameOptionsType,\n): void => {\n  const expressionContainerValue = sourceAttribute.value;\n  const destinationAttribute = path.node.openingElement.attributes\n    .find((attribute) => typeof attribute.name !== 'undefined' && attribute.name.name === destinationName);\n\n  if (destinationAttribute) {\n    path.node.openingElement.attributes.splice(\n      path.node.openingElement.attributes.indexOf(destinationAttribute),\n      1,\n    );\n  }\n\n  path.node.openingElement.attributes.splice(\n    path.node.openingElement.attributes.indexOf(sourceAttribute),\n    1,\n  );\n\n  const args = [\n    expressionContainerValue.expression,\n    styleModuleImportMapIdentifier,\n  ];\n\n  // Only provide options argument if the options are something other than default\n  // This helps save a few bits in the generated user code\n  if (options.handleMissingStyleName !== optionsDefaults.handleMissingStyleName\n    || options.autoResolveMultipleImports !== optionsDefaults.autoResolveMultipleImports) {\n    args.push(createObjectExpression(types, options));\n  }\n\n  const styleNameExpression = types.callExpression(\n    types.clone(importedHelperIndentifier),\n    args,\n  );\n\n  if (destinationAttribute) {\n    if (isStringLiteral(destinationAttribute.value)) {\n      path.node.openingElement.attributes.push(jSXAttribute(\n        jSXIdentifier(destinationName),\n        jSXExpressionContainer(\n          binaryExpression(\n            '+',\n            types.stringLiteral(`${destinationAttribute.value.value} `),\n            styleNameExpression,\n          ),\n        ),\n      ));\n    } else if (isJSXExpressionContainer(destinationAttribute.value)) {\n      path.node.openingElement.attributes.push(jSXAttribute(\n        jSXIdentifier(destinationName),\n        jSXExpressionContainer(\n          conditionalClassMerge(\n            destinationAttribute.value.expression,\n            styleNameExpression,\n          ),\n        ),\n      ));\n    } else {\n      throw new Error(`Unexpected attribute value: ${destinationAttribute.value}`);\n    }\n  } else {\n    path.node.openingElement.attributes.push(jSXAttribute(\n      jSXIdentifier(destinationName),\n      jSXExpressionContainer(\n        styleNameExpression,\n      ),\n    ));\n  }\n};\n"],"file":"replaceJsxExpressionContainer.js"}