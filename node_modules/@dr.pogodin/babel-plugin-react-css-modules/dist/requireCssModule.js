"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = require("fs");

var _path = require("path");

var _postcssModulesParser = _interopRequireDefault(require("@dr.pogodin/postcss-modules-parser"));

var _postcss = _interopRequireDefault(require("postcss"));

var _postcssModulesExtractImports = _interopRequireDefault(require("postcss-modules-extract-imports"));

var _postcssModulesLocalByDefault = _interopRequireDefault(require("postcss-modules-local-by-default"));

var _postcssModulesScope = _interopRequireDefault(require("postcss-modules-scope"));

var _postcssModulesValues = _interopRequireDefault(require("postcss-modules-values"));

var _getLocalIdent = _interopRequireWildcard(require("./getLocalIdent"));

var _optionsDefaults = _interopRequireDefault(require("./schemas/optionsDefaults"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getFiletypeOptions = (cssSourceFilePath, filetypes) => {
  const extension = cssSourceFilePath.slice(cssSourceFilePath.lastIndexOf('.'));
  const filetype = filetypes ? filetypes[extension] : null;
  return filetype;
};

const getSyntax = filetypeOptions => {
  if (!filetypeOptions || !filetypeOptions.syntax) {
    return null;
  } // eslint-disable-next-line global-require, import/no-dynamic-require


  return require(filetypeOptions.syntax);
};

const getExtraPlugins = filetypeOptions => {
  if (!filetypeOptions || !filetypeOptions.plugins) {
    return [];
  }

  return filetypeOptions.plugins.map(plugin => {
    if (Array.isArray(plugin)) {
      const [pluginName, pluginOptions] = plugin; // eslint-disable-next-line global-require, import/no-dynamic-require

      return require(pluginName)(pluginOptions);
    } // eslint-disable-next-line global-require, import/no-dynamic-require


    return require(plugin);
  });
};

const getTokens = (extraPluginsRunner, runner, cssSourceFilePath, filetypeOptions) => {
  const options = {
    from: cssSourceFilePath
  };

  if (filetypeOptions) {
    options.syntax = getSyntax(filetypeOptions);
  }

  let res = (0, _fs.readFileSync)(cssSourceFilePath, 'utf-8');

  if (extraPluginsRunner) {
    res = extraPluginsRunner.process(res, options);
  }

  res = runner.process(res, options);
  res.warnings().forEach(message => {
    // eslint-disable-next-line no-console
    console.warn(message.text);
  });
  return res.root.tokens;
};

var _default = (cssSourceFilePath, options) => {
  // eslint-disable-next-line prefer-const
  let runner;
  let generateScopedName;

  if (options.generateScopedName && typeof options.generateScopedName === 'function') {
    generateScopedName = options.generateScopedName;
  } else {
    generateScopedName = (clazz, resourcePath) => (0, _getLocalIdent.default)( // TODO: The loader context used by "css-loader" may has additional
    // stuff inside this argument (loader context), allowing for some edge
    // cases (though, presumably not with a typical configurations)
    // we don't support (yet?).
    {
      resourcePath
    }, options.generateScopedName || _optionsDefaults.default.generateScopedName, (0, _getLocalIdent.unescape)(clazz), {
      context: options.context || process.cwd(),
      // TODO: These options should match their counterparts in Webpack
      // configuration:
      //  - https://webpack.js.org/configuration/output/#outputhashdigest
      //  - https://webpack.js.org/configuration/output/#outputhashdigestlength
      //  - https://webpack.js.org/configuration/output/#outputhashfunction
      //  - https://webpack.js.org/configuration/output/#outputhashsalt
      // and they should be exposed as babel-plugin-react-css-modules
      // options. However, for now they are just hardcoded equal to
      // the Webpack's default settings.
      hashDigest: 'hex',
      hashDigestLength: 20,
      hashFunction: 'md4',
      hashSalt: '',
      // TODO: This one allows for some path modifications during
      // the transform. Probably, not a Webpack param.
      regExp: ''
    });
  }

  const filetypeOptions = getFiletypeOptions(cssSourceFilePath, options.filetypes);
  const extraPlugins = getExtraPlugins(filetypeOptions);
  const extraPluginsRunner = extraPlugins.length && (0, _postcss.default)(extraPlugins);

  const fetch = (to, from) => {
    const fromDirectoryPath = (0, _path.dirname)(from);
    const toPath = (0, _path.resolve)(fromDirectoryPath, to);
    return getTokens(extraPluginsRunner, runner, toPath, filetypeOptions);
  };

  const plugins = [_postcssModulesValues.default, _postcssModulesLocalByDefault.default, _postcssModulesExtractImports.default, (0, _postcssModulesScope.default)({
    generateScopedName
  }), new _postcssModulesParser.default({
    fetch
  })];
  runner = (0, _postcss.default)(plugins);
  return getTokens(extraPluginsRunner, runner, cssSourceFilePath, filetypeOptions);
};

exports.default = _default;
//# sourceMappingURL=requireCssModule.js.map